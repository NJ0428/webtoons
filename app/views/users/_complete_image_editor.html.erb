<!-- 로딩 스피너 -->
<div id="loadingSpinner" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-60">
  <div class="bg-white rounded-lg p-8 flex flex-col items-center space-y-4">
    <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500"></div>
    <div class="text-gray-700 font-medium" id="loadingText">로딩 중...</div>
  </div>
</div>

<!-- 이미지 편집기 모달 -->
<div id="imageEditorModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
  <div class="bg-white rounded-lg w-full max-w-6xl mx-4 h-5/6 flex flex-col">
    <!-- 편집기 헤더 -->
    <div class="flex justify-between items-center p-4 border-b">
      <div class="flex items-center space-x-4">
        <h3 id="editor-title" class="text-lg font-semibold">이미지 편집기</h3>
        <div class="flex items-center space-x-2 text-sm text-gray-600">
          <span>크기:</span>
          <span id="canvas-size">800 x 600</span>
        </div>
      </div>
      <div class="flex items-center space-x-2">
        <button onclick="testAddImage()" class="bg-purple-500 text-white px-4 py-2 rounded-lg text-sm hover:bg-purple-600">
          테스트 이미지
        </button>
        <button onclick="saveImage()" class="bg-green-500 text-white px-4 py-2 rounded-lg text-sm hover:bg-green-600">
          저장
        </button>
        <button onclick="closeImageEditor()" class="text-gray-400 hover:text-gray-600">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        </button>
      </div>
    </div>

    <!-- 편집기 본문 -->
    <div class="flex flex-1 overflow-hidden">
      <!-- 도구 패널 -->
      <div class="w-64 bg-gray-50 border-r p-4 overflow-y-auto">
        <!-- 파일 업로드 -->
        <div class="mb-6">
          <h4 class="font-medium text-gray-900 mb-3">이미지 가져오기</h4>
          <div class="space-y-3">
            <div class="border-2 border-dashed border-gray-300 rounded-lg p-4 text-center hover:border-blue-400 transition-colors">
              <input type="file" id="image-upload" accept="image/*" multiple class="hidden" onchange="handleImageUpload(event)">
              <button onclick="document.getElementById('image-upload').click()" class="w-full" id="upload-button">
                <div id="upload-content">
                  <svg class="mx-auto h-8 w-8 text-gray-400 mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                  </svg>
                  <p class="text-sm text-gray-600">클릭하여 이미지 업로드</p>
                  <p class="text-xs text-gray-400">JPG, PNG, GIF 지원</p>
                </div>
                <div id="upload-loading" class="hidden">
                  <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto mb-2"></div>
                  <p class="text-sm text-blue-600">업로드 중...</p>
                </div>
              </button>
            </div>
            
            <!-- 드래그 앤 드롭 영역 -->
            <div id="drop-zone" class="border-2 border-dashed border-gray-300 rounded-lg p-3 text-center text-sm text-gray-500 hover:border-green-400 transition-colors">
              또는 여기에 파일을 드래그하세요
            </div>
            
            <!-- 업로드된 이미지 미리보기 -->
            <div id="uploaded-images" class="space-y-2 max-h-32 overflow-y-auto">
              <!-- 업로드된 이미지들이 여기에 표시됩니다 -->
            </div>
          </div>
        </div>

        <!-- 기본 도구 -->
        <div class="mb-6">
          <h4 class="font-medium text-gray-900 mb-3">기본 도구</h4>
          <div class="grid grid-cols-2 gap-2">
            <button onclick="setTool('select')" class="tool-btn bg-blue-500 text-white p-2 rounded text-xs hover:bg-blue-600">
              선택
            </button>
            <button onclick="setTool('crop')" class="tool-btn bg-gray-200 p-2 rounded text-xs hover:bg-gray-300">
              자르기
            </button>
            <button onclick="setTool('draw')" class="tool-btn bg-gray-200 p-2 rounded text-xs hover:bg-gray-300">
              그리기
            </button>
            <button onclick="setTool('text')" class="tool-btn bg-gray-200 p-2 rounded text-xs hover:bg-gray-300">
              텍스트
            </button>
            <button onclick="setTool('shape')" class="tool-btn bg-gray-200 p-2 rounded text-xs hover:bg-gray-300">
              도형
            </button>
          </div>
        </div>

        <!-- 자르기 도구 -->
        <div id="crop-tools" class="mb-6 hidden">
          <h4 class="font-medium text-gray-900 mb-3">이미지 자르기</h4>
          <div class="space-y-3">
            <div class="text-sm text-gray-600 bg-blue-50 p-2 rounded">
              이미지를 선택한 후 자르기 영역을 드래그하세요
            </div>
            <div class="grid grid-cols-2 gap-2">
              <button onclick="startCropping()" class="bg-green-100 text-green-800 p-2 rounded text-xs hover:bg-green-200">
                자르기 시작
              </button>
              <button onclick="applyCrop()" class="bg-blue-100 text-blue-800 p-2 rounded text-xs hover:bg-blue-200">
                자르기 적용
              </button>
              <button onclick="cancelCrop()" class="bg-gray-100 text-gray-800 p-2 rounded text-xs hover:bg-gray-200">
                취소
              </button>
              <button onclick="resetCrop()" class="bg-red-100 text-red-800 p-2 rounded text-xs hover:bg-red-200">
                초기화
              </button>
            </div>
            <div class="space-y-2">
              <div class="text-xs text-gray-600">자르기 비율:</div>
              <div class="grid grid-cols-2 gap-1">
                <button onclick="setCropRatio('free')" class="crop-ratio-btn bg-gray-100 text-gray-800 p-1 rounded text-xs hover:bg-gray-200">
                  자유
                </button>
                <button onclick="setCropRatio('1:1')" class="crop-ratio-btn bg-gray-100 text-gray-800 p-1 rounded text-xs hover:bg-gray-200">
                  1:1
                </button>
                <button onclick="setCropRatio('4:3')" class="crop-ratio-btn bg-gray-100 text-gray-800 p-1 rounded text-xs hover:bg-gray-200">
                  4:3
                </button>
                <button onclick="setCropRatio('16:9')" class="crop-ratio-btn bg-gray-100 text-gray-800 p-1 rounded text-xs hover:bg-gray-200">
                  16:9
                </button>
              </div>
            </div>
            <div id="crop-info" class="text-xs text-gray-600 bg-gray-50 p-2 rounded hidden">
              <!-- 자르기 정보가 여기에 표시됩니다 -->
            </div>
          </div>
        </div>

        <!-- 브러시 설정 -->
        <div class="mb-6">
          <h4 class="font-medium text-gray-900 mb-3">브러시</h4>
          <div class="space-y-3">
            <div>
              <label class="block text-sm text-gray-600 mb-1">크기</label>
              <input type="range" id="brush-size" min="1" max="50" value="5" class="w-full" onchange="setBrushSize(this.value)">
              <span id="brush-size-value" class="text-xs text-gray-500">5px</span>
            </div>
            <div>
              <label class="block text-sm text-gray-600 mb-1">색상</label>
              <input type="color" id="brush-color" value="#000000" class="w-full h-8 rounded" onchange="setBrushColor(this.value)">
            </div>
          </div>
        </div>

        <!-- 색상 조절 -->
        <div class="mb-6">
          <h4 class="font-medium text-gray-900 mb-3">색상 조절</h4>
          <div class="space-y-3">
            <div>
              <label class="block text-sm text-gray-600 mb-1">색상 (Hue)</label>
              <input type="range" id="hue-slider" min="-180" max="180" value="0" class="w-full" onchange="adjustHue(this.value)">
              <div class="flex justify-between text-xs text-gray-500">
                <span>-180°</span>
                <span id="hue-value">0°</span>
                <span>180°</span>
              </div>
            </div>
            <div>
              <label class="block text-sm text-gray-600 mb-1">채도 (Saturation)</label>
              <input type="range" id="saturation-slider" min="-100" max="100" value="0" class="w-full" onchange="adjustSaturation(this.value)">
              <div class="flex justify-between text-xs text-gray-500">
                <span>-100%</span>
                <span id="saturation-value">0%</span>
                <span>100%</span>
              </div>
            </div>
            <div>
              <label class="block text-sm text-gray-600 mb-1">명도 (Lightness)</label>
              <input type="range" id="lightness-slider" min="-100" max="100" value="0" class="w-full" onchange="adjustLightness(this.value)">
              <div class="flex justify-between text-xs text-gray-500">
                <span>-100%</span>
                <span id="lightness-value">0%</span>
                <span>100%</span>
              </div>
            </div>
            <div class="grid grid-cols-2 gap-2 mt-3">
              <button onclick="resetColorAdjustments()" class="bg-gray-100 text-gray-800 p-2 rounded text-xs hover:bg-gray-200">
                초기화
              </button>
              <button onclick="applyColorAdjustments()" class="bg-blue-100 text-blue-800 p-2 rounded text-xs hover:bg-blue-200">
                적용
              </button>
            </div>
          </div>
        </div>

        <!-- 이미지 조작 -->
        <div class="mb-6">
          <h4 class="font-medium text-gray-900 mb-3">이미지 조작</h4>
          <div class="grid grid-cols-2 gap-2">
            <button onclick="rotateImage(90)" class="bg-purple-100 text-purple-800 p-2 rounded text-xs hover:bg-purple-200">
              90° 회전
            </button>
            <button onclick="rotateImage(-90)" class="bg-purple-100 text-purple-800 p-2 rounded text-xs hover:bg-purple-200">
              -90° 회전
            </button>
            <button onclick="flipImage('horizontal')" class="bg-indigo-100 text-indigo-800 p-2 rounded text-xs hover:bg-indigo-200">
              좌우 뒤집기
            </button>
            <button onclick="flipImage('vertical')" class="bg-indigo-100 text-indigo-800 p-2 rounded text-xs hover:bg-indigo-200">
              상하 뒤집기
            </button>
            <button onclick="duplicateImage()" class="bg-cyan-100 text-cyan-800 p-2 rounded text-xs hover:bg-cyan-200">
              복제
            </button>
            <button onclick="bringToFront()" class="bg-orange-100 text-orange-800 p-2 rounded text-xs hover:bg-orange-200">
              앞으로
            </button>
            <button onclick="sendToBack()" class="bg-yellow-100 text-yellow-800 p-2 rounded text-xs hover:bg-yellow-200">
              뒤로
            </button>
            <button onclick="deleteSelected()" class="bg-red-100 text-red-800 p-2 rounded text-xs hover:bg-red-200">
              삭제
            </button>
          </div>
        </div>

        <!-- 객체 정보 -->
        <div class="mb-6">
          <h4 class="font-medium text-gray-900 mb-3">선택된 객체</h4>
          <div class="space-y-2">
            <button onclick="showObjectInfo()" class="w-full bg-gray-100 text-gray-800 p-2 rounded text-xs hover:bg-gray-200">
              객체 정보 보기
            </button>
            <div id="object-info" class="text-xs text-gray-600 bg-gray-50 p-2 rounded hidden">
              <!-- 객체 정보가 여기에 표시됩니다 -->
            </div>
          </div>
        </div>

        <!-- 레이어 -->
        <div class="mb-6">
          <h4 class="font-medium text-gray-900 mb-3">레이어</h4>
          <div class="space-y-2">
            <button onclick="addAllImagesToCanvas()" class="w-full bg-teal-100 text-teal-800 p-2 rounded text-xs hover:bg-teal-200">
              모든 이미지 추가
            </button>
            <button onclick="addTextLayer()" class="w-full bg-green-100 text-green-800 p-2 rounded text-xs hover:bg-green-200">
              텍스트 추가
            </button>
            <button onclick="addShapeLayer('rect')" class="w-full bg-blue-100 text-blue-800 p-2 rounded text-xs hover:bg-blue-200">
              사각형 추가
            </button>
            <button onclick="addShapeLayer('circle')" class="w-full bg-red-100 text-red-800 p-2 rounded text-xs hover:bg-red-200">
              원 추가
            </button>
          </div>
        </div>

        <!-- 작업 -->
        <div class="mb-6">
          <h4 class="font-medium text-gray-900 mb-3">작업</h4>
          <div class="space-y-2">
            <button onclick="undoAction()" class="w-full bg-gray-100 text-gray-800 p-2 rounded text-xs hover:bg-gray-200">
              실행 취소
            </button>
            <button onclick="clearCanvas()" class="w-full bg-red-100 text-red-800 p-2 rounded text-xs hover:bg-red-200">
              전체 지우기
            </button>
          </div>
        </div>
      </div>

      <!-- 캔버스 영역 -->
      <div class="flex-1 p-4 bg-gray-100 flex items-center justify-center relative">
        <!-- 캔버스 로딩 스피너 -->
        <div id="canvas-loading" class="absolute inset-0 bg-gray-100 bg-opacity-90 flex items-center justify-center z-10 hidden">
          <div class="bg-white rounded-lg p-6 shadow-lg flex flex-col items-center space-y-3">
            <div class="animate-spin rounded-full h-10 w-10 border-b-2 border-blue-500"></div>
            <div class="text-gray-700 font-medium" id="canvas-loading-text">캔버스 초기화 중...</div>
          </div>
        </div>
        
        <div class="bg-white shadow-lg rounded-lg overflow-hidden">
          <canvas id="image-canvas" width="800" height="600" style="border: 1px solid #ccc;"></canvas>
        </div>
      </div>
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>

<script>
// 이미지 편집기 관련 변수
let canvas;
let currentTool = 'select';
let brushSize = 5;
let brushColor = '#000000';
let uploadedImages = [];

// 색상 조절 관련 변수
let currentHue = 0;
let currentSaturation = 0;
let currentLightness = 0;
let originalImageFilters = new Map(); // 원본 이미지 필터 저장

// 자르기 관련 변수
let cropRect = null;
let isCropping = false;
let cropRatio = 'free';
let originalImage = null;

// 로딩 스피너 표시/숨김 함수들
function showLoadingSpinner(text = '로딩 중...') {
  const spinner = document.getElementById('loadingSpinner');
  const loadingText = document.getElementById('loadingText');
  if (spinner && loadingText) {
    loadingText.textContent = text;
    spinner.classList.remove('hidden');
    spinner.classList.add('flex');
  }
}

function hideLoadingSpinner() {
  const spinner = document.getElementById('loadingSpinner');
  if (spinner) {
    spinner.classList.add('hidden');
    spinner.classList.remove('flex');
  }
}

function showCanvasLoading(text = '캔버스 초기화 중...') {
  const canvasLoading = document.getElementById('canvas-loading');
  const loadingText = document.getElementById('canvas-loading-text');
  if (canvasLoading && loadingText) {
    loadingText.textContent = text;
    canvasLoading.classList.remove('hidden');
  }
}

function hideCanvasLoading() {
  const canvasLoading = document.getElementById('canvas-loading');
  if (canvasLoading) {
    canvasLoading.classList.add('hidden');
  }
}

function showUploadLoading() {
  const uploadContent = document.getElementById('upload-content');
  const uploadLoading = document.getElementById('upload-loading');
  if (uploadContent && uploadLoading) {
    uploadContent.classList.add('hidden');
    uploadLoading.classList.remove('hidden');
  }
}

function hideUploadLoading() {
  const uploadContent = document.getElementById('upload-content');
  const uploadLoading = document.getElementById('upload-loading');
  if (uploadContent && uploadLoading) {
    uploadContent.classList.remove('hidden');
    uploadLoading.classList.add('hidden');
  }
}

// 이미지 편집기 열기
function openImageEditor(title, imageUrl) {
  console.log('이미지 편집기 열기:', title, imageUrl);
  
  showLoadingSpinner('편집기 초기화 중...');
  
  document.getElementById('imageEditorModal').classList.remove('hidden');
  document.getElementById('imageEditorModal').classList.add('flex');
  document.getElementById('editor-title').textContent = `${title} - 이미지 편집기`;
  
  // 업로드된 이미지 배열 초기화
  uploadedImages = [];
  updateImagePreview();
  
  // 캔버스 초기화
  setTimeout(() => {
    initializeCanvas(imageUrl);
    initializeDragAndDrop();
    hideLoadingSpinner();
  }, 100);
}

// 이미지 편집기 닫기
function closeImageEditor() {
  document.getElementById('imageEditorModal').classList.add('hidden');
  document.getElementById('imageEditorModal').classList.remove('flex');
  
  if (canvas) {
    canvas.dispose();
    canvas = null;
  }
}

// 캔버스 초기화
function initializeCanvas(imageUrl) {
  console.log('캔버스 초기화 시작');
  showCanvasLoading('캔버스 초기화 중...');
  
  const canvasElement = document.getElementById('image-canvas');
  if (!canvasElement) {
    console.error('캔버스 엘리먼트를 찾을 수 없습니다.');
    hideCanvasLoading();
    return;
  }
  
  canvas = new fabric.Canvas(canvasElement, {
    width: 800,
    height: 600,
    backgroundColor: '#ffffff'
  });
  
  console.log('Fabric.js 캔버스 생성 완료');
  
  // 배경 이미지 로드
  if (imageUrl) {
    console.log('배경 이미지 로드 시작:', imageUrl);
    showCanvasLoading('배경 이미지 로드 중...');
    loadBackgroundImage(imageUrl);
  } else {
    hideCanvasLoading();
  }
  
  // 그리기 모드 설정
  canvas.isDrawingMode = false;
  canvas.freeDrawingBrush.width = brushSize;
  canvas.freeDrawingBrush.color = brushColor;
  
  console.log('캔버스 초기화 완료');
}

// 배경 이미지 로드
function loadBackgroundImage(imageUrl) {
  fabric.Image.fromURL(imageUrl, function(img) {
    console.log('배경 이미지 로드 성공');
    
    const canvasWidth = canvas.getWidth();
    const canvasHeight = canvas.getHeight();
    const scale = Math.min(canvasWidth / img.width, canvasHeight / img.height) * 0.8;
    
    img.set({
      left: (canvasWidth - img.width * scale) / 2,
      top: (canvasHeight - img.height * scale) / 2,
      scaleX: scale,
      scaleY: scale,
      selectable: false,
      evented: false
    });
    
    canvas.add(img);
    canvas.sendToBack(img);
    canvas.renderAll();
    
    hideCanvasLoading();
  }, { 
    crossOrigin: 'anonymous',
    onError: function() {
      console.error('배경 이미지 로드 실패');
      hideCanvasLoading();
    }
  });
}

// 파일 업로드 처리
function handleImageUpload(event) {
  console.log('파일 업로드 시작');
  const files = event.target.files;
  
  if (files.length > 0) {
    showUploadLoading();
    
    let processedFiles = 0;
    const totalFiles = files.length;
    
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      if (file.type.startsWith('image/')) {
        console.log('이미지 파일 처리:', file.name);
        loadImageFile(file, () => {
          processedFiles++;
          if (processedFiles === totalFiles) {
            hideUploadLoading();
          }
        });
      } else {
        alert('이미지 파일만 업로드 가능합니다.');
        processedFiles++;
        if (processedFiles === totalFiles) {
          hideUploadLoading();
        }
      }
    }
  }
}

// 이미지 파일 로드
function loadImageFile(file, callback) {
  const reader = new FileReader();
  
  reader.onload = function(e) {
    const imageUrl = e.target.result;
    console.log('파일 읽기 완료:', file.name);
    
    // 업로드된 이미지를 배열에 저장
    uploadedImages.push({
      name: file.name,
      url: imageUrl,
      size: file.size
    });
    
    // 미리보기 업데이트
    updateImagePreview();
    
    // 즉시 캔버스에 추가
    addImageToCanvas(imageUrl, file.name);
    
    if (callback) callback();
  };
  
  reader.onerror = function() {
    console.error('파일 읽기 실패:', file.name);
    if (callback) callback();
  };
  
  reader.readAsDataURL(file);
}

// 캔버스에 이미지 추가 (수정된 버전)
function addImageToCanvas(imageUrl, fileName) {
  console.log('캔버스에 이미지 추가 시작:', fileName);
  
  if (!canvas) {
    console.error('캔버스가 초기화되지 않았습니다.');
    alert('캔버스가 초기화되지 않았습니다. 편집기를 다시 열어주세요.');
    return;
  }
  
  showCanvasLoading(`이미지 추가 중: ${fileName}`);
  
  fabric.Image.fromURL(imageUrl, function(img) {
    if (!img) {
      console.error('이미지 로드 실패');
      alert('이미지 로드에 실패했습니다.');
      hideCanvasLoading();
      return;
    }
    
    console.log('이미지 로드 성공:', img.width, 'x', img.height);
    
    // 캔버스 크기
    const canvasWidth = canvas.getWidth();
    const canvasHeight = canvas.getHeight();
    
    // 이미지 크기 조정
    let scale = 0.3; // 기본 스케일
    if (img.width > canvasWidth || img.height > canvasHeight) {
      scale = Math.min(canvasWidth / img.width, canvasHeight / img.height) * 0.3;
    }
    
    // 랜덤 위치 (겹치지 않게)
    const left = 50 + Math.random() * (canvasWidth - img.width * scale - 100);
    const top = 50 + Math.random() * (canvasHeight - img.height * scale - 100);
    
    img.set({
      left: left,
      top: top,
      scaleX: scale,
      scaleY: scale,
      selectable: true,
      moveable: true,
      hasControls: true,
      hasBorders: true
    });
    
    console.log('이미지 설정 완료:', { left, top, scale });
    
    // 캔버스에 추가
    canvas.add(img);
    canvas.setActiveObject(img);
    canvas.renderAll();
    
    hideCanvasLoading();
    console.log('이미지가 캔버스에 성공적으로 추가되었습니다.');
    
  }, { 
    crossOrigin: 'anonymous',
    onError: function() {
      console.error('이미지 로드 실패:', fileName);
      hideCanvasLoading();
    }
  });
}

// 테스트 이미지 추가
function testAddImage() {
  console.log('테스트 이미지 추가');
  const testImageUrl = 'https://picsum.photos/400/300?random=' + Math.floor(Math.random() * 1000);
  addImageToCanvas(testImageUrl, 'test-image.jpg');
}

// 이미지 미리보기 업데이트
function updateImagePreview() {
  const previewContainer = document.getElementById('uploaded-images');
  if (!previewContainer) return;
  
  previewContainer.innerHTML = '';
  
  uploadedImages.forEach((image, index) => {
    const previewItem = document.createElement('div');
    previewItem.className = 'flex items-center space-x-2 p-2 bg-white rounded border hover:bg-gray-50';
    
    previewItem.innerHTML = `
      <img src="${image.url}" alt="${image.name}" class="w-8 h-8 object-cover rounded">
      <div class="flex-1 min-w-0">
        <p class="text-xs font-medium text-gray-900 truncate">${image.name}</p>
        <p class="text-xs text-gray-500">${formatFileSize(image.size)}</p>
      </div>
      <button onclick="addImageToCanvas('${image.url}', '${image.name}')" 
              class="text-blue-600 hover:text-blue-800 text-xs">
        추가
      </button>
      <button onclick="removeUploadedImage(${index})" 
              class="text-red-600 hover:text-red-800 text-xs">
        삭제
      </button>
    `;
    
    previewContainer.appendChild(previewItem);
  });
}

// 업로드된 이미지 제거
function removeUploadedImage(index) {
  uploadedImages.splice(index, 1);
  updateImagePreview();
}

// 파일 크기 포맷팅
function formatFileSize(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

// 드래그 앤 드롭 초기화
function initializeDragAndDrop() {
  const dropZone = document.getElementById('drop-zone');
  if (!dropZone) return;
  
  dropZone.addEventListener('dragover', function(e) {
    e.preventDefault();
    dropZone.classList.add('border-blue-400', 'bg-blue-50');
    dropZone.textContent = '파일을 놓으세요';
  });
  
  dropZone.addEventListener('dragleave', function(e) {
    e.preventDefault();
    dropZone.classList.remove('border-blue-400', 'bg-blue-50');
    dropZone.textContent = '또는 여기에 파일을 드래그하세요';
  });
  
  dropZone.addEventListener('drop', function(e) {
    e.preventDefault();
    dropZone.classList.remove('border-blue-400', 'bg-blue-50');
    dropZone.textContent = '또는 여기에 파일을 드래그하세요';
    
    const files = e.dataTransfer.files;
    if (files.length > 0) {
      showUploadLoading();
      
      let processedFiles = 0;
      const totalFiles = files.length;
      
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        if (file.type.startsWith('image/')) {
          loadImageFile(file, () => {
            processedFiles++;
            if (processedFiles === totalFiles) {
              hideUploadLoading();
            }
          });
        } else {
          processedFiles++;
          if (processedFiles === totalFiles) {
            hideUploadLoading();
          }
        }
      }
    }
  });
}

// 도구 설정
function setTool(tool) {
  currentTool = tool;
  
  // 모든 도구 버튼 초기화
  document.querySelectorAll('.tool-btn').forEach(btn => {
    btn.classList.remove('bg-blue-500', 'text-white');
    btn.classList.add('bg-gray-200');
  });
  
  // 선택된 도구 버튼 활성화
  event.target.classList.remove('bg-gray-200');
  event.target.classList.add('bg-blue-500', 'text-white');
  
  // 자르기 도구 패널 표시/숨김
  const cropTools = document.getElementById('crop-tools');
  if (tool === 'crop') {
    cropTools.classList.remove('hidden');
  } else {
    cropTools.classList.add('hidden');
    // 자르기 모드 종료
    if (isCropping) {
      cancelCrop();
    }
  }
  
  if (!canvas) return;
  
  switch(tool) {
    case 'select':
      canvas.isDrawingMode = false;
      canvas.selection = true;
      break;
    case 'crop':
      canvas.isDrawingMode = false;
      canvas.selection = true;
      break;
    case 'draw':
      canvas.isDrawingMode = true;
      canvas.selection = false;
      break;
    case 'text':
      canvas.isDrawingMode = false;
      canvas.selection = true;
      break;
    case 'shape':
      canvas.isDrawingMode = false;
      canvas.selection = true;
      break;
  }
}

// 브러시 크기 설정
function setBrushSize(size) {
  brushSize = parseInt(size);
  document.getElementById('brush-size-value').textContent = size + 'px';
  if (canvas) {
    canvas.freeDrawingBrush.width = brushSize;
  }
}

// 브러시 색상 설정
function setBrushColor(color) {
  brushColor = color;
  if (canvas) {
    canvas.freeDrawingBrush.color = brushColor;
  }
}

// 텍스트 레이어 추가
function addTextLayer() {
  if (!canvas) return;
  
  const text = new fabric.IText('텍스트를 입력하세요', {
    left: 100,
    top: 100,
    fontFamily: 'Arial',
    fontSize: 20,
    fill: brushColor
  });
  
  canvas.add(text);
  canvas.setActiveObject(text);
  canvas.renderAll();
}

// 도형 레이어 추가
function addShapeLayer(shapeType) {
  if (!canvas) return;
  
  let shape;
  
  switch(shapeType) {
    case 'rect':
      shape = new fabric.Rect({
        left: 100,
        top: 100,
        width: 100,
        height: 100,
        fill: 'transparent',
        stroke: brushColor,
        strokeWidth: 2
      });
      break;
    case 'circle':
      shape = new fabric.Circle({
        left: 100,
        top: 100,
        radius: 50,
        fill: 'transparent',
        stroke: brushColor,
        strokeWidth: 2
      });
      break;
  }
  
  if (shape) {
    canvas.add(shape);
    canvas.setActiveObject(shape);
    canvas.renderAll();
  }
}

// 모든 이미지를 캔버스에 추가
function addAllImagesToCanvas() {
  uploadedImages.forEach(image => {
    addImageToCanvas(image.url, image.name);
  });
}

// 이미지 회전
function rotateImage(angle) {
  console.log('회전 시도:', angle);
  
  if (!canvas) {
    console.error('캔버스가 없습니다.');
    alert('캔버스가 초기화되지 않았습니다.');
    return;
  }
  
  const activeObject = canvas.getActiveObject();
  console.log('선택된 객체:', activeObject);
  
  if (activeObject) {
    const currentAngle = activeObject.angle || 0;
    const newAngle = currentAngle + angle;
    console.log('현재 각도:', currentAngle, '새 각도:', newAngle);
    
    activeObject.rotate(newAngle);
    canvas.renderAll();
    console.log('회전 완료');
  } else {
    alert('회전할 객체를 선택해주세요.');
  }
}

// 이미지 뒤집기
function flipImage(direction) {
  console.log('뒤집기 시도:', direction);
  
  if (!canvas) {
    console.error('캔버스가 없습니다.');
    alert('캔버스가 초기화되지 않았습니다.');
    return;
  }
  
  const activeObject = canvas.getActiveObject();
  console.log('선택된 객체:', activeObject);
  
  if (activeObject) {
    if (direction === 'horizontal') {
      const currentFlipX = activeObject.flipX || false;
      activeObject.set('flipX', !currentFlipX);
      console.log('좌우 뒤집기:', !currentFlipX);
    } else if (direction === 'vertical') {
      const currentFlipY = activeObject.flipY || false;
      activeObject.set('flipY', !currentFlipY);
      console.log('상하 뒤집기:', !currentFlipY);
    }
    canvas.renderAll();
    console.log('뒤집기 완료');
  } else {
    alert('뒤집을 객체를 선택해주세요.');
  }
}

// 이미지 복제
function duplicateImage() {
  console.log('복제 시도');
  
  if (!canvas) {
    console.error('캔버스가 없습니다.');
    alert('캔버스가 초기화되지 않았습니다.');
    return;
  }
  
  const activeObject = canvas.getActiveObject();
  console.log('선택된 객체:', activeObject);
  
  if (activeObject) {
    activeObject.clone(function(cloned) {
      console.log('복제된 객체:', cloned);
      
      cloned.set({
        left: cloned.left + 20,
        top: cloned.top + 20
      });
      
      canvas.add(cloned);
      canvas.setActiveObject(cloned);
      canvas.renderAll();
      
      console.log('복제 완료');
    });
  } else {
    alert('복제할 객체를 선택해주세요.');
  }
}

// 앞으로 보내기
function bringToFront() {
  console.log('앞으로 보내기 시도');
  
  if (!canvas) {
    console.error('캔버스가 없습니다.');
    alert('캔버스가 초기화되지 않았습니다.');
    return;
  }
  
  const activeObject = canvas.getActiveObject();
  console.log('선택된 객체:', activeObject);
  
  if (activeObject) {
    canvas.bringToFront(activeObject);
    canvas.renderAll();
    console.log('앞으로 보내기 완료');
  } else {
    alert('앞으로 보낼 객체를 선택해주세요.');
  }
}

// 뒤로 보내기
function sendToBack() {
  console.log('뒤로 보내기 시도');
  
  if (!canvas) {
    console.error('캔버스가 없습니다.');
    alert('캔버스가 초기화되지 않았습니다.');
    return;
  }
  
  const activeObject = canvas.getActiveObject();
  console.log('선택된 객체:', activeObject);
  
  if (activeObject) {
    canvas.sendToBack(activeObject);
    canvas.renderAll();
    console.log('뒤로 보내기 완료');
  } else {
    alert('뒤로 보낼 객체를 선택해주세요.');
  }
}

// 객체 삭제
function deleteSelected() {
  console.log('삭제 시도');
  
  if (!canvas) {
    console.error('캔버스가 없습니다.');
    return;
  }
  
  const activeObject = canvas.getActiveObject();
  console.log('선택된 객체:', activeObject);
  
  if (activeObject) {
    canvas.remove(activeObject);
    canvas.renderAll();
    console.log('삭제 완료');
  } else {
    alert('삭제할 객체를 선택해주세요.');
  }
}

// 선택된 객체 정보 표시
function showObjectInfo() {
  if (!canvas) return;
  
  const infoDiv = document.getElementById('object-info');
  const activeObject = canvas.getActiveObject();
  
  if (activeObject) {
    const info = {
      type: activeObject.type,
      left: Math.round(activeObject.left),
      top: Math.round(activeObject.top),
      width: Math.round(activeObject.width * activeObject.scaleX),
      height: Math.round(activeObject.height * activeObject.scaleY),
      angle: Math.round(activeObject.angle || 0),
      flipX: activeObject.flipX || false,
      flipY: activeObject.flipY || false
    };
    
    infoDiv.innerHTML = `
      <div class="space-y-1">
        <div><strong>타입:</strong> ${info.type}</div>
        <div><strong>위치:</strong> (${info.left}, ${info.top})</div>
        <div><strong>크기:</strong> ${info.width} x ${info.height}</div>
        <div><strong>회전:</strong> ${info.angle}°</div>
        <div><strong>뒤집기:</strong> 좌우(${info.flipX}) 상하(${info.flipY})</div>
      </div>
    `;
    infoDiv.classList.remove('hidden');
    
    console.log('선택된 객체 정보:', info);
  } else {
    infoDiv.innerHTML = '<div class="text-center text-gray-500">선택된 객체가 없습니다.</div>';
    infoDiv.classList.remove('hidden');
    console.log('선택된 객체가 없습니다.');
  }
}

// 실행 취소
function undoAction() {
  const objects = canvas.getObjects();
  if (objects.length > 0) {
    canvas.remove(objects[objects.length - 1]);
    canvas.renderAll();
  }
}

// 캔버스 지우기
function clearCanvas() {
  if (confirm('모든 편집 내용을 지우시겠습니까?')) {
    canvas.clear();
    canvas.backgroundColor = '#ffffff';
    canvas.renderAll();
  }
}

// 이미지 저장
function saveImage() {
  if (!canvas) return;
  
  showLoadingSpinner('이미지 저장 중...');
  
  setTimeout(() => {
    try {
      const dataURL = canvas.toDataURL({
        format: 'png',
        quality: 1.0
      });
      
      const link = document.createElement('a');
      link.download = 'edited-image.png';
      link.href = dataURL;
      
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      hideLoadingSpinner();
      alert('이미지가 저장되었습니다!');
    } catch (error) {
      console.error('이미지 저장 실패:', error);
      hideLoadingSpinner();
      alert('이미지 저장에 실패했습니다.');
    }
  }, 100);
}

// 색상 조절 함수들
function adjustHue(value) {
  currentHue = parseInt(value);
  document.getElementById('hue-value').textContent = value + '°';
  applyColorFilters();
}

function adjustSaturation(value) {
  currentSaturation = parseInt(value);
  document.getElementById('saturation-value').textContent = value + '%';
  applyColorFilters();
}

function adjustLightness(value) {
  currentLightness = parseInt(value);
  document.getElementById('lightness-value').textContent = value + '%';
  applyColorFilters();
}

// 색상 필터 적용
function applyColorFilters() {
  if (!canvas) return;
  
  const activeObject = canvas.getActiveObject();
  if (!activeObject || activeObject.type !== 'image') {
    alert('이미지를 선택해주세요.');
    return;
  }
  
  showCanvasLoading('색상 필터 적용 중...');
  
  setTimeout(() => {
    try {
      console.log('색상 필터 적용:', { hue: currentHue, saturation: currentSaturation, lightness: currentLightness });
      
      // 기존 필터 제거
      activeObject.filters = [];
      
      // 색상(Hue) 필터 적용
      if (currentHue !== 0) {
        const hueFilter = new fabric.Image.filters.HueRotation({
          rotation: currentHue / 180 // -1 to 1 범위로 변환
        });
        activeObject.filters.push(hueFilter);
      }
      
      // 채도(Saturation) 필터 적용
      if (currentSaturation !== 0) {
        const saturationFilter = new fabric.Image.filters.Saturation({
          saturation: currentSaturation / 100 // -1 to 1 범위로 변환
        });
        activeObject.filters.push(saturationFilter);
      }
      
      // 명도(Brightness) 필터 적용
      if (currentLightness !== 0) {
        const brightnessFilter = new fabric.Image.filters.Brightness({
          brightness: currentLightness / 100 // -1 to 1 범위로 변환
        });
        activeObject.filters.push(brightnessFilter);
      }
      
      // 필터 적용
      activeObject.applyFilters();
      canvas.renderAll();
      
      hideCanvasLoading();
      console.log('색상 필터 적용 완료');
    } catch (error) {
      console.error('색상 필터 적용 실패:', error);
      hideCanvasLoading();
      alert('색상 필터 적용에 실패했습니다.');
    }
  }, 100);Object.filters.push(hueFilter);
  }
  
  // 채도(Saturation) 필터 적용
  if (currentSaturation !== 0) {
    const saturationFilter = new fabric.Image.filters.Saturation({
      saturation: currentSaturation / 100 // -1 to 1 범위로 변환
    });
    activeObject.filters.push(saturationFilter);
  }
  
  // 명도(Brightness) 필터 적용
  if (currentLightness !== 0) {
    const brightnessFilter = new fabric.Image.filters.Brightness({
      brightness: currentLightness / 100 // -1 to 1 범위로 변환
    });
    activeObject.filters.push(brightnessFilter);
  }
  
  // 필터 적용 및 캔버스 렌더링
  activeObject.applyFilters();
  canvas.renderAll();
  
  console.log('색상 필터 적용 완료');
}

// 색상 조절 초기화
function resetColorAdjustments() {
  console.log('색상 조절 초기화');
  
  // 슬라이더 값 초기화
  currentHue = 0;
  currentSaturation = 0;
  currentLightness = 0;
  
  document.getElementById('hue-slider').value = 0;
  document.getElementById('saturation-slider').value = 0;
  document.getElementById('lightness-slider').value = 0;
  
  document.getElementById('hue-value').textContent = '0°';
  document.getElementById('saturation-value').textContent = '0%';
  document.getElementById('lightness-value').textContent = '0%';
  
  // 선택된 이미지의 필터 제거
  if (canvas) {
    const activeObject = canvas.getActiveObject();
    if (activeObject && activeObject.type === 'image') {
      activeObject.filters = [];
      activeObject.applyFilters();
      canvas.renderAll();
      console.log('이미지 필터 초기화 완료');
    }
  }
}

// 색상 조절 적용 (현재 설정을 확정)
function applyColorAdjustments() {
  if (!canvas) return;
  
  const activeObject = canvas.getActiveObject();
  if (!activeObject || activeObject.type !== 'image') {
    alert('이미지를 선택해주세요.');
    return;
  }
  
  console.log('색상 조절 적용 확정');
  
  // 현재 필터 상태를 원본으로 저장
  const objectId = activeObject.id || Date.now().toString();
  activeObject.id = objectId;
  
  originalImageFilters.set(objectId, {
    hue: currentHue,
    saturation: currentSaturation,
    lightness: currentLightness
  });
  
  alert('색상 조절이 적용되었습니다!');
  console.log('색상 조절 적용 완료');
}

// 이미지에 고급 필터 적용 함수들
function applyImageFilter(filterType) {
  if (!canvas) return;
  
  const activeObject = canvas.getActiveObject();
  if (!activeObject || activeObject.type !== 'image') {
    alert('이미지를 선택해주세요.');
    return;
  }
  
  console.log('이미지 필터 적용:', filterType);
  
  let filter;
  
  switch(filterType) {
    case 'grayscale':
      filter = new fabric.Image.filters.Grayscale();
      break;
    case 'sepia':
      filter = new fabric.Image.filters.Sepia();
      break;
    case 'invert':
      filter = new fabric.Image.filters.Invert();
      break;
    case 'blur':
      filter = new fabric.Image.filters.Blur({ blur: 0.1 });
      break;
    case 'sharpen':
      filter = new fabric.Image.filters.Convolute({
        matrix: [0, -1, 0, -1, 5, -1, 0, -1, 0]
      });
      break;
    case 'emboss':
      filter = new fabric.Image.filters.Convolute({
        matrix: [-2, -1, 0, -1, 1, 1, 0, 1, 2]
      });
      break;
    default:
      console.log('알 수 없는 필터 타입:', filterType);
      return;
  }
  
  if (filter) {
    activeObject.filters.push(filter);
    activeObject.applyFilters();
    canvas.renderAll();
    console.log('필터 적용 완료:', filterType);
  }
}

// 모든 필터 제거
function clearAllFilters() {
  if (!canvas) return;
  
  const activeObject = canvas.getActiveObject();
  if (!activeObject || activeObject.type !== 'image') {
    alert('이미지를 선택해주세요.');
    return;
  }
  
  console.log('모든 필터 제거');
  
  activeObject.filters = [];
  activeObject.applyFilters();
  canvas.renderAll();
  
  // 색상 조절 슬라이더도 초기화
  resetColorAdjustments();
  
  console.log('모든 필터 제거 완료');
}

// 이미지 자르기 관련 함수들
function startCropping() {
  console.log('자르기 시작');
  
  if (!canvas) {
    alert('캔버스가 초기화되지 않았습니다.');
    return;
  }
  
  const activeObject = canvas.getActiveObject();
  if (!activeObject || activeObject.type !== 'image') {
    alert('자를 이미지를 선택해주세요.');
    return;
  }
  
  console.log('선택된 이미지:', activeObject);
  
  // 원본 이미지 저장
  originalImage = activeObject;
  isCropping = true;
  
  // 자르기 사각형 생성
  const imgBounds = activeObject.getBoundingRect();
  const cropWidth = Math.min(200, imgBounds.width * 0.5);
  const cropHeight = Math.min(150, imgBounds.height * 0.5);
  
  cropRect = new fabric.Rect({
    left: imgBounds.left + (imgBounds.width - cropWidth) / 2,
    top: imgBounds.top + (imgBounds.height - cropHeight) / 2,
    width: cropWidth,
    height: cropHeight,
    fill: 'rgba(0, 0, 255, 0.1)',
    stroke: '#0066ff',
    strokeWidth: 2,
    strokeDashArray: [5, 5],
    selectable: true,
    hasControls: true,
    hasBorders: true,
    transparentCorners: false,
    cornerColor: '#0066ff',
    cornerSize: 8
  });
  
  // 비율 제한 적용
  applyCropRatio();
  
  canvas.add(cropRect);
  canvas.setActiveObject(cropRect);
  canvas.renderAll();
  
  // 자르기 정보 표시
  updateCropInfo();
  
  console.log('자르기 사각형 생성 완료');
}

function applyCropRatio() {
  if (!cropRect) return;
  
  const currentWidth = cropRect.width;
  const currentHeight = cropRect.height;
  
  switch(cropRatio) {
    case '1:1':
      const size = Math.min(currentWidth, currentHeight);
      cropRect.set({ width: size, height: size });
      break;
    case '4:3':
      if (currentWidth / currentHeight > 4/3) {
        cropRect.set({ width: currentHeight * 4/3 });
      } else {
        cropRect.set({ height: currentWidth * 3/4 });
      }
      break;
    case '16:9':
      if (currentWidth / currentHeight > 16/9) {
        cropRect.set({ width: currentHeight * 16/9 });
      } else {
        cropRect.set({ height: currentWidth * 9/16 });
      }
      break;
    case 'free':
    default:
      // 자유 비율 - 제한 없음
      break;
  }
  
  canvas.renderAll();
}

function setCropRatio(ratio) {
  console.log('자르기 비율 설정:', ratio);
  cropRatio = ratio;
  
  // 모든 비율 버튼 초기화
  document.querySelectorAll('.crop-ratio-btn').forEach(btn => {
    btn.classList.remove('bg-blue-500', 'text-white');
    btn.classList.add('bg-gray-100', 'text-gray-800');
  });
  
  // 선택된 비율 버튼 활성화
  event.target.classList.remove('bg-gray-100', 'text-gray-800');
  event.target.classList.add('bg-blue-500', 'text-white');
  
  // 현재 자르기 사각형에 비율 적용
  if (cropRect && isCropping) {
    applyCropRatio();
    updateCropInfo();
  }
}

function applyCrop() {
  console.log('자르기 적용');
  
  if (!canvas || !cropRect || !originalImage || !isCropping) {
    alert('자르기를 시작해주세요.');
    return;
  }
  
  // 자르기 영역 정보 가져오기
  const cropBounds = cropRect.getBoundingRect();
  const imgBounds = originalImage.getBoundingRect();
  
  console.log('자르기 영역:', cropBounds);
  console.log('이미지 영역:', imgBounds);
  
  // 이미지 내부의 상대적 위치 계산
  const relativeLeft = (cropBounds.left - imgBounds.left) / imgBounds.width;
  const relativeTop = (cropBounds.top - imgBounds.top) / imgBounds.height;
  const relativeWidth = cropBounds.width / imgBounds.width;
  const relativeHeight = cropBounds.height / imgBounds.height;
  
  console.log('상대적 자르기 정보:', { relativeLeft, relativeTop, relativeWidth, relativeHeight });
  
  // 원본 이미지의 실제 크기 기준으로 자르기 영역 계산
  const actualLeft = relativeLeft * originalImage.width;
  const actualTop = relativeTop * originalImage.height;
  const actualWidth = relativeWidth * originalImage.width;
  const actualHeight = relativeHeight * originalImage.height;
  
  console.log('실제 자르기 정보:', { actualLeft, actualTop, actualWidth, actualHeight });
  
  // 새로운 캔버스에 자른 이미지 그리기
  const tempCanvas = document.createElement('canvas');
  const tempCtx = tempCanvas.getContext('2d');
  
  tempCanvas.width = actualWidth;
  tempCanvas.height = actualHeight;
  
  // 원본 이미지 엘리먼트 가져오기
  const imgElement = originalImage.getElement();
  
  tempCtx.drawImage(
    imgElement,
    actualLeft, actualTop, actualWidth, actualHeight,
    0, 0, actualWidth, actualHeight
  );
  
  // 자른 이미지를 새로운 Fabric 이미지로 생성
  const croppedDataURL = tempCanvas.toDataURL();
  
  fabric.Image.fromURL(croppedDataURL, function(croppedImg) {
    console.log('자른 이미지 생성 완료');
    
    // 자른 이미지를 원래 위치에 배치
    croppedImg.set({
      left: cropBounds.left,
      top: cropBounds.top,
      scaleX: cropBounds.width / croppedImg.width,
      scaleY: cropBounds.height / croppedImg.height,
      selectable: true,
      moveable: true,
      hasControls: true,
      hasBorders: true
    });
    
    // 원본 이미지와 자르기 사각형 제거
    canvas.remove(originalImage);
    canvas.remove(cropRect);
    
    // 자른 이미지 추가
    canvas.add(croppedImg);
    canvas.setActiveObject(croppedImg);
    canvas.renderAll();
    
    // 자르기 모드 종료
    resetCropState();
    
    alert('이미지 자르기가 완료되었습니다!');
    console.log('자르기 적용 완료');
  });
}

function cancelCrop() {
  console.log('자르기 취소');
  
  if (cropRect) {
    canvas.remove(cropRect);
    canvas.renderAll();
  }
  
  resetCropState();
  console.log('자르기 취소 완료');
}

function resetCrop() {
  console.log('자르기 초기화');
  
  if (cropRect) {
    canvas.remove(cropRect);
  }
  
  if (originalImage) {
    canvas.setActiveObject(originalImage);
  }
  
  resetCropState();
  canvas.renderAll();
  
  console.log('자르기 초기화 완료');
}

function resetCropState() {
  cropRect = null;
  isCropping = false;
  originalImage = null;
  
  // 자르기 정보 숨기기
  const cropInfo = document.getElementById('crop-info');
  cropInfo.classList.add('hidden');
  
  // 비율 버튼 초기화
  document.querySelectorAll('.crop-ratio-btn').forEach(btn => {
    btn.classList.remove('bg-blue-500', 'text-white');
    btn.classList.add('bg-gray-100', 'text-gray-800');
  });
  
  cropRatio = 'free';
}

function updateCropInfo() {
  if (!cropRect) return;
  
  const cropInfo = document.getElementById('crop-info');
  const bounds = cropRect.getBoundingRect();
  
  cropInfo.innerHTML = `
    <div class="space-y-1">
      <div><strong>자르기 영역</strong></div>
      <div>위치: (${Math.round(bounds.left)}, ${Math.round(bounds.top)})</div>
      <div>크기: ${Math.round(bounds.width)} x ${Math.round(bounds.height)}</div>
      <div>비율: ${cropRatio}</div>
    </div>
  `;
  
  cropInfo.classList.remove('hidden');
}

// 캔버스 이벤트 리스너 추가 (자르기 정보 업데이트용)
function addCropEventListeners() {
  if (!canvas) return;
  
  canvas.on('object:modified', function(e) {
    if (e.target === cropRect && isCropping) {
      applyCropRatio();
      updateCropInfo();
    }
  });
  
  canvas.on('object:moving', function(e) {
    if (e.target === cropRect && isCropping) {
      updateCropInfo();
    }
  });
  
  canvas.on('object:scaling', function(e) {
    if (e.target === cropRect && isCropping) {
      applyCropRatio();
      updateCropInfo();
    }
  });
}

// 캔버스 초기화 시 이벤트 리스너 추가
function initializeCanvas(imageUrl) {
  console.log('캔버스 초기화 시작');
  
  const canvasElement = document.getElementById('image-canvas');
  if (!canvasElement) {
    console.error('캔버스 엘리먼트를 찾을 수 없습니다.');
    return;
  }
  
  canvas = new fabric.Canvas(canvasElement, {
    width: 800,
    height: 600,
    backgroundColor: '#ffffff'
  });
  
  console.log('Fabric.js 캔버스 생성 완료');
  
  // 자르기 이벤트 리스너 추가
  addCropEventListeners();
  
  // 배경 이미지 로드
  if (imageUrl) {
    console.log('배경 이미지 로드 시작:', imageUrl);
    loadBackgroundImage(imageUrl);
  }
  
  // 그리기 모드 설정
  canvas.isDrawingMode = false;
  canvas.freeDrawingBrush.width = brushSize;
  canvas.freeDrawingBrush.color = brushColor;
  
  console.log('캔버스 초기화 완료');
}

// 키보드 단축키
document.addEventListener('keydown', function(e) {
  if (!canvas) return;
  
  if (e.ctrlKey && e.key === 'z') {
    e.preventDefault();
    undoAction();
  }
  
  if (e.key === 'Delete') {
    const activeObject = canvas.getActiveObject();
    if (activeObject) {
      canvas.remove(activeObject);
      canvas.renderAll();
    }
  }
  
  // 색상 조절 단축키
  if (e.ctrlKey && e.key === 'r') {
    e.preventDefault();
    resetColorAdjustments();
  }
  
  // 자르기 단축키
  if (e.key === 'Escape' && isCropping) {
    cancelCrop();
  }
  
  if (e.ctrlKey && e.key === 'x' && currentTool === 'crop') {
    e.preventDefault();
    startCropping();
  }
});
</script>